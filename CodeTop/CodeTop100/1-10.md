# [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

## 题目描述

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

## 解题思路

滑动窗口的核心要点是：

- 大窗口的结果一定比小窗口更好，这样 r 才不会左移
- 窗口的信息可以进行复用，这样 r 在向右移动一次之后，能很快计算出来新的窗口的状态信息

滑动窗口的过程如下：

![image-20240301195916048](1-10/image-20240301195916048.png)

![image-20240301195926649](1-10/image-20240301195926649.png)

时间复杂度：O(N), 空间复杂度：O(1)

## 解题代码

```java
class Solution {
    public int lengthOfLongestSubstring(String ss) {
        char[] s = ss.toCharArray();
        int n = s.length;
        int r = 0;
        int ans = 0;
        int start = 0, end = 0;
        int[] cache = new int[1000];
        for (int i = 0; i < n; i++) {
            if (i != 0) {
                cache[s[i - 1]]--;
            }
            while (r < n && cache[s[r]] == 0) {
                cache[s[r]]++;
                r++;
            }
            ans = max(ans, r - i);
        }
        return ans;
    }
    int max(int x, int y) {
        return x > y ? x : y;
    }
}
```

## 举一反三

- [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring)
- [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum)

# [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list)

