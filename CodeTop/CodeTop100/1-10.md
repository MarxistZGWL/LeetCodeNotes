# [3. 无重复字符的最长子串](https://leetcode.cn/problems/longest-substring-without-repeating-characters/)

## 题目描述

给定一个字符串 `s` ，请你找出其中不含有重复字符的 **最长子串** 的长度。

**示例 1:**

```
输入: s = "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```

**示例 2:**

```
输入: s = "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```

**示例 3:**

```
输入: s = "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

**提示：**

- `0 <= s.length <= 5 * 104`
- `s` 由英文字母、数字、符号和空格组成

## 解题思路

滑动窗口的核心要点是：

- 大窗口的结果一定比小窗口更好，这样 r 才不会左移
- 窗口的信息可以进行复用，这样 r 在向右移动一次之后，能很快计算出来新的窗口的状态信息

滑动窗口的过程如下：

![image-20240301195916048](1-10/image-20240301195916048.png)

![image-20240301195926649](1-10/image-20240301195926649.png)

时间复杂度：O(N), 空间复杂度：O(1)

## 解题代码

```java
class Solution {
    public int lengthOfLongestSubstring(String ss) {
        char[] s = ss.toCharArray();
        int n = s.length;
        int r = 0;
        int ans = 0;
        int start = 0, end = 0;
        int[] cache = new int[1000];
        for (int i = 0; i < n; i++) {
            if (i != 0) {
                cache[s[i - 1]]--;
            }
            while (r < n && cache[s[r]] == 0) {
                cache[s[r]]++;
                r++;
            }
            ans = max(ans, r - i);
        }
        return ans;
    }
    int max(int x, int y) {
        return x > y ? x : y;
    }
}
```

## 举一反三

- [76. 最小覆盖子串](https://leetcode.cn/problems/minimum-window-substring)
- [209. 长度最小的子数组](https://leetcode.cn/problems/minimum-size-subarray-sum)

# [206. 反转链表](https://leetcode.cn/problems/reverse-linked-list)

## 题目描述

Case 1:

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

![img](1-10/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

Case 2:

![img](1-10/rev1ex2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

Case 3：

```
输入：head = []
输出：[]
```

## 解题思路

所有的链表题目，最重要的是，要有一个伪造的头节点。

这道题目属于模板题目，没有技巧可言，背下来就好了。

```java
    ListNode reverse(ListNode head, ListNode tail) {
        ListNode p = head;
        ListNode q = tail;
        while (p != tail) {
            ListNode s = p.next;
            p.next = q;
            q = p;
            p = s;
        }
        return q;
    }
```

## 解题代码

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        return reverse(head, null);
    }
    ListNode reverse(ListNode head, ListNode tail) {
        ListNode p = head;
        ListNode q = tail;
        while (p != tail) {
            ListNode s = p.next;
            p.next = q;
            q = p;
            p = s;
        }
        return q;
    }
}
```

## 举一反三

- [92. 反转链表 II](https://leetcode.cn/problems/reverse-linked-list-ii/)
- [25. K 个一组翻转链表](https://leetcode.cn/problems/reverse-nodes-in-k-group)
- [21. 合并两个有序链表](https://leetcode.cn/problems/merge-two-sorted-lists)

# [146. LRU 缓存](https://leetcode.cn/problems/lru-cache/)

## 题目描述

请你设计并实现一个满足 [LRU (最近最少使用) 缓存](https://baike.baidu.com/item/LRU) 约束的数据结构。

实现 `LRUCache` 类：

- `LRUCache(int capacity)` 以 **正整数** 作为容量 `capacity` 初始化 LRU 缓存
- `int get(int key)` 如果关键字 `key` 存在于缓存中，则返回关键字的值，否则返回 `-1` 。
- `void put(int key, int value)` 如果关键字 `key` 已经存在，则变更其数据值 `value` ；如果不存在，则向缓存中插入该组 `key-value` 。如果插入操作导致关键字数量超过 `capacity` ，则应该 **逐出** 最久未使用的关键字。

函数 `get` 和 `put` 必须以 `O(1)` 的平均时间复杂度运行。

**示例：**

```
输入
["LRUCache", "put", "put", "get", "put", "get", "put", "get", "get", "get"]
[[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]
输出
[null, null, null, 1, null, -1, null, -1, 3, 4]

解释
LRUCache lRUCache = new LRUCache(2);
lRUCache.put(1, 1); // 缓存是 {1=1}
lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}
lRUCache.get(1);    // 返回 1
lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}
lRUCache.get(2);    // 返回 -1 (未找到)
lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}
lRUCache.get(1);    // 返回 -1 (未找到)
lRUCache.get(3);    // 返回 3
lRUCache.get(4);    // 返回 4
```

## 解题思路

使用 HashMap + 链表结合的方式来进行本题目的完成

或者直接继承 LinkedHashMap, 需要注意的是，需要重写 removeEldestEntry(Map.Entry<Integer, Integer> eldest) 方法

## 解题代码

```java
class LRUCache extends LinkedHashMap<Integer, Integer>{
    private int capacity;
    
    public LRUCache(int capacity) {
        super(capacity, 0.75F, true);
        this.capacity = capacity;
    }

    public int get(int key) {
        return super.getOrDefault(key, -1);
    }

    public void put(int key, int value) {
        super.put(key, value);
    }

    @Override
    protected boolean removeEldestEntry(Map.Entry<Integer, Integer> eldest) {
        return size() > capacity; 
    }
}
```

```java
class LRUCache {
    class Node {
        int key, val;
        Node next;
        Node prev;
    }
    Node head, tail;
    HashMap<Integer, Node> cache;
    int capacity;
    int size;
    public LRUCache(int capacity) {
        head = new Node();
        tail = new Node();
        head.next = tail;
        tail.prev = head;
        this.capacity = capacity;
        size = 0;
        cache = new HashMap<Integer, Node>(capacity);
    }
    void moveHead(Node node) {
        node.prev.next = node.next;
        node.next.prev = node.prev;
        node.next = head.next;
        head.next.prev = node;
        node.prev = head;
        head.next = node;
    }
    public int get(int key) {
        Node node = cache.get(key);
        if (node == null) {
            return -1;
        } else {
            moveHead(node);
            return node.val;
        }
    }
    public void put(int key, int value) {
        Node node = cache.get(key);
        if (node == null) {
            node = new Node();
            node.key = key;
            node.val = value;
            node.next = head.next;
            head.next.prev = node;
            node.prev = head;
            head.next = node;
            cache.put(key, node);
            size++;
            if (size > capacity) {
                cache.remove(tail.prev.key);
                tail.prev = tail.prev.prev;
                tail.prev.next = tail;
            }
        } else {
            node.val = value;
            cache.put(key, node);
            moveHead(node);
        }
    }
}
```

## 举一反三

- [LFU 缓存](https://leetcode.cn/problems/lfu-cache/)

# [215. 数组中的第K个最大元素](https://leetcode.cn/problems/kth-largest-element-in-an-array/)

## 题目描述

给定整数数组 `nums` 和整数 `k`，请返回数组中第 `k` 个最大的元素。

请注意，你需要找的是数组排序后的第 `k` 个最大的元素，而不是第 `k` 个不同的元素。

你必须设计并实现时间复杂度为 `O(n)` 的算法解决此问题。

**示例 1:**

```
输入: [3,2,1,5,6,4], k = 2
输出: 5
```

**示例 2:**

```
输入: [3,2,3,1,2,4,5,5,6], k = 4
输出: 4
```

## 解题思路

可以使用快速排序的办法，或者使用堆排序的办法。

快速排序的办法就是利用快速排序的分割函数每次都能讲数组分割为以中心轴为界，一侧全部大于另一侧的格式。

堆排序的办法就是小顶堆，如果本元素大于小顶堆或者小顶堆中的元素个数小于 `k` ，那么放入，否则无视就可以了。

## 解题代码

```java
class Solution {
    public int findKthLargest(int[] nums, int k) {
        return find(nums, 0, nums.length - 1, k);
    }
    int find(int[] nums, int l, int r, int k) {
        int idx = partition(nums, l, r);
        if (idx == k - 1) {
            return nums[idx];
        } else if (idx < k - 1) {
            return find(nums, idx + 1, r, k);
        } else {
            return find(nums, l, idx - 1, k);
        }
    }
    int partition(int[] nums, int l, int r) {
        int p = nums[l];
        while (l < r) {
            while (l < r && nums[r] <= p) r--;
            nums[l] = nums[r];
            while (l < r && nums[l] > p) l++;
            nums[r] = nums[l];
        }
        nums[l] = p;
        return l;
    }
}
```

## 举一反三

- [347. 前 K 个高频元素](https://leetcode.cn/problems/top-k-frequent-elements/)
- [414. 第三大的数](https://leetcode.cn/problems/third-maximum-number/)
- [703. 数据流中的第 K 大元素](https://leetcode.cn/problems/kth-largest-element-in-a-stream/)
- [973. 最接近原点的 K 个点](https://leetcode.cn/problems/k-closest-points-to-origin/)
